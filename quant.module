<?php

/**
 * @file
 * Support exporting to quant.
 */

/**
 * Implements hook_help().
 */
function quant_help($section) {
  switch ($section) {
    case 'quant/config':
      return '';

    case 'quant/api':
      return '';
  }
}

/**
 * Implements hook_menu().
 */
function quant_menu() {
  $items['admin/config/services/quant'] = array(
    'title' => 'Quant',
    'description' => 'Configure the Quant static site generator.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('quant_config'),
    'file' => 'quant.admin.inc',
    'access arguments' => array('configure quant'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/config/services/quant/settings'] = array(
    'title' => 'Config',
    'description' => 'Configure the Quant static site generator.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('quant_config'),
    'file' => 'quant.admin.inc',
    'access arguments' => array('configure quant'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );

  $items['admin/config/services/quant/seed'] = array(
    'title' => 'Seed',
    'description' => 'Hydrate the static representation of the Drupal site.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('quant_seed_settings'),
    'file' => 'quant.admin.inc',
    'access arguments' => array('bulk quant export'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );

  // Custom quant view controller.
  $items['node/%node/quant'] = array(
    'title callback' => 'quant_page_title',
    'title arguments' => array(1),
    'page callback' => 'quant_page_view',
    'page arguments' => array(1),
    'file' => 'quant.renderer.inc',
    'access callback' => TRUE,
  );

  return $items;
}

/**
 * Implements hook_admin_paths().
 */
function quant_admin_paths() {
  return array(
    'admin/quant/config' => TRUE,
    'admin/quant/seed' => TRUE,
    'node/%node/quant' => FALSE,
  );
}

/**
 * Implements hook_permission()
 */
function quant_permission() {
  return array(
    'configure quant' => array(
      'description' => t('Configure the Quant exporter'),
      'title' => t('Configure quant'),
      'restrict access' => TRUE,
    ),
    'bulk quant export' => array(
      'description' => t('Trigger a bulk export/seed via Quant'),
      'title' => t('Bulk Quant Export'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_node_insert().
 */
function quant_node_insert($node) {
  $entity_info = array(
    'entity' => $node,
    'type' => 'node',
    'op' => 'update',
    'original' => $node,
  );

  drupal_register_shutdown_function('_quant_post_entity_op', $entity_info);
}

/**
 * Implements hook_node_update().
 */
function quant_node_update($node) {
  $original = isset($entity->original) ? $entity->original : NULL;
  $entity_info = array(
    'entity' => $node,
    'type' => 'node',
    'op' => 'update',
    'original' => $original,
  );

  drupal_register_shutdown_function('_quant_post_entity_op', $entity_info);
}

/**
 * Post entity operation hook.
 *
 * This should be registered as a shutdown function so that it
 * can operate after the db_transaction has finished.
 */
function _quant_post_entity_op($entity_info) {
  $entity = $entity_info['entity'];
  list($id) = entity_extract_ids($entity_info['type'], $entity_info['entity']);
  list($url, $context) = _quant_prepare_entity($entity_info['type'], $id);

  quant_seed($url, $context);
  quant_export_drupal_pages();
}

/**
 * Seed a node.
 *
 * @param int $nid
 *   The node id to send.
 * @param array $context
 *   The batch context.
 * @param array $batch_context
 *   The context of the batch process.
 */
function quant_seed($url, $context = array(), $batch_context = array()) {
  // This clears the message bag as we don't want this to be
  // rendered with the static output.
  // drupal_get_messages();

  $response = drupal_http_request($url . "?_quant=" . strtotime('now'));

  if (!property_exists($response, 'data')) {
    watchdog('quant', 'Unable to complete subrequest %error %request', array(
      '%error' => $response->error,
      '%request' => json_encode($response),
    ), WATCHDOG_ERROR);
    return FALSE;
  }

  // Path alias might not be what we want.
  $path = parse_url($url, PHP_URL_PATH);
  $path = ltrim($path, '/');

  if (empty($path)) {
    // Homepage is a request to /, ltrim removes that we need to
    // not have the leading slash when trying to find the alias.
    // If we use an empty string drupal_get_path_alias will use
    // the current request path which will cause node updates to
    // run twice.
    $path = '/';
  }

  $alias = drupal_get_path_alias($path);

  if (empty($alias)) {
    $alias = $path;
  }

  $markup = $response->data;

  $meta = array();

  drupal_alter('quant_meta', $meta, $context);
  module_invoke_all('quant_seed', $alias, $markup, $meta, $context);
}

/**
 * Prepare a file export.
 */
function quant_seed_file($url, $context = array()) {
  $meta = array();
  drupal_alter('quant_file_meta', $meta, $context);
  module_invoke_all('quant_seed_file', $url, $context);
}

/**
 * Implements hook_quant_meta_alter().
 */
function quant_quant_meta_alter(&$meta, $context) {
  $meta = [
    'published' => null,
    'transitions' => [],
    'info' => [],
  ];

  if (empty($context['entity'])) {
    return;
  }

  $meta['published'] = $context['entity']->status;

  // @TODO: Transition support.
  $meta['transitions'] = [];

  $meta['published_revision'] = $context['entity']->vid;

  $user = user_load($context['entity']->uid);

  // @TODO: node info.
  $meta['info'] = [
    'author' => $user->mail,
    'date_timestamp' => $context['entity']->changed,
  ];
}

/**
 * Prepare an entity for exporting.
 *
 * @return array
 *   The path with context for seeding.
 */
function _quant_prepare_entity($type, $entity_id) {
  global $base_url;
  $entity = entity_load($type, [$entity_id]);

  if (empty($entity)) {
    return FALSE;
  }

  $entity = reset($entity);

  $uri = entity_uri($type, $entity);
  $url = $base_url . "/{$uri['path']}";
  return [
    $url,
    [
      'entity' => $entity,
    ],
  ];
}

/**
 * Prepare a batch process for the node entity type.
 *
 * @param array $nids
 *   A list of nodes to export.
 */
function _quant_batch_nodes($nids = array()) {
  global $base_url;

  dpm('batching nodes');

  $ops = array();

  foreach ($nids as $nid) {
    list($url, $context) = _quant_prepare_entity('node', $nid);
    $ops[] = array(
      'quant_seed',
      array($url, $context),
    );
  }

  // Batch the homepage.
  $ops[] = array('quant_seed', array("$base_url/", array()));

  $batch = array(
    'title' => t('Quant seeding'),
    'operations' => $ops,
    'finished' => '_quant_batch_complete',
    'init_message' => t('Initialising...'),
    'progress_message' => t('Operation @current out of @total'),
    'error_message' => t('Unable to export'),
    'file' => drupal_get_path('module', 'quant') . 'quant.module',
  );

  return $batch;
}

/**
 * Create the batch process to export the form.
 *
 * @param array $form
 *   The form render array.
 * @param array $form_state
 *   The submitted form values.
 */
function _quant_seed_prepare($form, $form_state) {
  if (!variable_get('quant_seed_entity_node')) {
    drupal_set_message(t('Nodes are not configured to be exported.'));
    return;
  }

  // Fetch the node ids.
  $nids = db_select('node', 'n')
    ->fields('n', array('nid'))
    ->execute()
    ->fetchCol();

  $batch = _quant_batch_nodes($nids);

  batch_set($batch);
}

/**
 * Generate warning messsages for the seed form.
 *
 * @param array &$form
 *   The form render array.
 */
function _quant_get_seed_warnings(&$form) {
  $cssagg = variable_get('preprocess_css');
  $jsagg = variable_get('preprocess_js');

  if ($cssagg == 1 && $jsagg == 1) {
    // Good things get no warnings.
    return;
  }

  if ($cssagg == 0) {
    drupal_set_message(t('CSS aggregation is disabled'), 'warning');
  }

  if ($jsagg == 0) {
    drupal_set_message(t('JS aggregation is disabled'), 'warning');
  }

  drupal_set_message(t('This could lead to performance issues. To resolve, visit /admin/config/development/performance'), 'warning');
}

/**
 * Export static pages.
 *
 * This gathers front and error pages and prepares them to be
 * exported.
 */
function quant_export_drupal_pages() {
  global $base_url;

  dpm('here');

  $special_pages = array(
    '/' => variable_get('site_frontpage', 'node'),
    '/_quant404' => variable_get('site_404'),
    '/_quant403' => variable_get('site_403'),
  );

  foreach ($special_pages as $path => $route) {
    if (empty($route)) {
      continue;
    }
    quant_seed("{$base_url}{$path}", array());
  }
}

function quant_test() {
  list($url, $context) = _quant_prepare_entity('node', 1);
  quant_seed($url, $context);

  global $base_url;

  quant_seed("$base_url/", array());

  // dpm('and home');

  // dpm(_quant_prepare_entity('node', 1));

  // $aliases = [
  //   '/file.jpg',
  //   '/no-extension',
  // ];

  // foreach ($aliases as $a) {
  //   $ext = strtolower(pathinfo($a, PATHINFO_EXTENSION));
  //   dpm($ext);
  // }

}
