<?php

/**
 * @file
 * Support exporting to quant.
 */

/**
 * The regular expression to find theme assets.
 *
 * @var string
 */
define('QUANT_THEME_FILE_MASK', '/^.+(.jpe?g|.png|.svg|.ttf|.woff|.woff2|.otf)$/i');

/**
 * Quant verbose logging.
 */
define('QUANT_VERBOSE', 'verbose');

/**
 * The elapsed time a short-live token can be alive for.
 *
 * @var string
 */
define('QUANT_ELAPSED_TIME', '+1 minute');

/**
 * Implements hook_help().
 */
function quant_help($section) {
  switch ($section) {
    case 'quant/config':
      return '';

    case 'quant/api':
      return '';
  }
}

/**
 * Implements hook_menu().
 */
function quant_menu() {
  $items['admin/config/services/quant'] = array(
    'title' => 'Quant',
    'description' => 'Configure the Quant static site generator.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('quant_config'),
    'file' => 'quant.admin.inc',
    'access arguments' => array('configure quant'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/config/services/quant/settings'] = array(
    'title' => 'Config',
    'description' => 'Configure the Quant static site generator.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('quant_config'),
    'file' => 'quant.admin.inc',
    'access arguments' => array('configure quant'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );

  $items['admin/config/services/quant/seed'] = array(
    'title' => 'Seed',
    'description' => 'Hydrate the static representation of the Drupal site.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('quant_seed_settings'),
    'file' => 'quant.admin.inc',
    'access arguments' => array('bulk quant export'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );

  // Custom quant view controller.
  $items['node/%node/quant'] = array(
    'title callback' => 'quant_page_title',
    'title arguments' => array(1),
    'page callback' => 'quant_page_view',
    'page arguments' => array(1),
    'file' => 'quant.renderer.inc',
    'access callback' => TRUE,
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 *
 * We intercept the standard route wildcard argument loader
 * and replace it with quant_node_menu_load. This allows
 * us to load a revision with a query parameter and have the
 * standard router context continue to operate as expected.
 */
function quant_menu_alter(&$items) {

  // Altering the node route breaks displaysuite.
  if (!variable_get('quant_draft_revisions', FALSE)) {
    return;
  }
  $node_route = $items['node/%node'];
  unset($items['node/%node']);
  $items['node/%quant_node_menu'] = $node_route;
}

/**
 * Implements hook_admin_paths().
 */
function quant_admin_paths() {
  return array(
    'admin/quant/config' => TRUE,
    'admin/quant/seed' => TRUE,
    'node/%node/quant' => FALSE,
  );
}

/**
 * Implements hook_permission()
 */
function quant_permission() {
  return array(
    'configure quant' => array(
      'description' => t('Configure the Quant exporter'),
      'title' => t('Configure quant'),
      'restrict access' => TRUE,
    ),
    'bulk quant export' => array(
      'description' => t('Trigger a bulk export/seed via Quant'),
      'title' => t('Bulk Quant Export'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Wildcard menu node loader.
 */
function quant_node_menu_load($nid) {
  $params = drupal_get_query_parameters();

  if (isset($params['quant_revision'])) {
    $node = node_load($nid, $params['quant_revision']);
    // Override the status - this prevents drupal from adding the standard
    // unpublished classes to the node.
    $node->status = 1;
    return $node;
  }

  return node_load($nid);
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function quant_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  $params = drupal_get_query_parameters();
  if (isset($params['quant_token'])) {
    unset($data['tabs']);
  }
}

/**
 * Implements hook_cron().
 */
function quant_cron() {
  // Tokens can be used multiple times in a single request, this causes issues
  // with the access check by removing the token clean up to core cron we can
  // persist a single token for multiple uses, the 1 minute timeout still ensures
  // that the token will expire naturally.
  db_query('TRUNCATE {quant_token}');
}

/**
 * Implements hook_node_access().
 *
 * This is not called for all users - if a user has the 'bypass node access'
 * permission this will not be called (eg. uid 1).
 *
 * Additionally 'access content' needs to be given to anonymous for this to
 * take effect.
 *
 * @see node_access
 */
function quant_node_access($node, $op, $account) {
  $params = drupal_get_query_parameters();

  if (is_string($node)) {
    return NODE_ACCESS_IGNORE;
  }

  if (!variable_get('quant_draft_revisions', FALSE)) {
    return NODE_ACCESS_IGNORE;
  }

  if (isset($params['quant_token'])) {
    return quant_token_validate($node->nid) ? NODE_ACCESS_ALLOW : NODE_ACCESS_DENY;
  }

  return NODE_ACCESS_IGNORE;
}

/**
 * Implements hook_node_load().
 */
function quant_node_load($nodes) {
  $params = drupal_get_query_parameters();
  if (empty($params['quant_token'])) {
    return;
  }
  foreach ($nodes as $node) {
    if (quant_token_validate($node->nid)) {
      $node->status = 1;
    }
  }
}

/**
 * Implements hook_node_insert().
 */
function quant_node_insert($node) {
  $entity_info = array(
    'entity' => $node,
    'type' => 'node',
    'op' => 'insert',
    'original' => $node,
  );

  if (!empty($node->op)) {
    drupal_register_shutdown_function('_quant_shutdown', $entity_info);
  }
}

/**
 * Implements hook_node_update().
 */
function quant_node_update($node) {
  $original = isset($entity->original) ? $entity->original : NULL;
  $entity_info = array(
    'entity' => $node,
    'type' => 'node',
    'op' => 'update',
    'original' => $original,
  );

  if (!empty($node->op)) {
    drupal_register_shutdown_function('_quant_shutdown', $entity_info);
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function quant_form_node_delete_confirm_alter(&$form, $form_state, $id) {
  list($url) = _quant_prepare_entity('node', $form['nid']['#value']);
  $form['alias'] = [
    '#type' => 'value',
    '#value' => $url,
  ];

  // Drupal 7 doesn't have a pre-delete operation, so we need to hook
  // into the delete confirmation form to get the alias.
  $form['#submit'][] = 'quant_node_delete_form_action';
}

/**
 * Callback for the delete form.
 */
function quant_node_delete_form_action($form, $form_state) {
  quant_api_unpublish_route($form_state['values']['alias']);
}


/**
 * Implements hook_taxonomy_term_insert().
 */
function quant_taxonomy_term_insert($term) {
  $entity_info = array(
    'entity' => $term,
    'type' => 'taxonomy_term',
    'op' => 'insert',
    'original' => $term,
  );

  drupal_register_shutdown_function('_quant_shutdown', $entity_info);
}

/**
 * Implements hook_taxonomy_term_update().
 */
function quant_taxonomy_term_update($term) {
  $entity_info = array(
    'entity' => $term,
    'type' => 'taxonomy_term',
    'op' => 'insert',
    'original' => $term,
  );

  drupal_register_shutdown_function('_quant_shutdown', $entity_info);
}

/**
 * Intermediary shutdown function.
 *
 * This is an intermediary shutdown function to ensure that quants
 * export will always be run after other processes.
 *
 */
function _quant_shutdown($entity_info) {
  drupal_register_shutdown_function('_quant_post_entity_op', $entity_info);
}

/**
 * Post entity operation hook.
 *
 * This should be registered as a shutdown function so that it
 * can operate after the db_transaction has finished.
 */
function _quant_post_entity_op($entity_info) {

  list($id) = entity_extract_ids($entity_info['type'], $entity_info['entity']);
  list($url, $context) = _quant_prepare_entity($entity_info['type'], $id);

  if (isset($entity_info['token'])) {
    $context['token'] = $entity_info['token'];
  }

  $context['id'] = $id;
  quant_seed($url, $context);
}

/**
 * Seed a url.
 *
 * @param string $url
 *   The url to seed.
 * @param array $context
 *   The context of the seed, usually includes entity info.
 * @param array $batch_context
 *   The context of the batch process.
 */
function quant_seed($url, $context = array(), $batch_context = array()) {
  global $base_url;

  $path = parse_url($url, PHP_URL_PATH);

  if (path_is_admin($path)) {
    quant_log('Skip: !path is an admin path', array('!path' => $path));
    return;
  }

  quant_log('Preparing to send !url', array('!url' => $url));

  $options = array(
    'headers' => array(
      'Host' => variable_get('quant_hostname', $base_url),
      'User-Agent' => 'Quant (+http://quantcdn.io)'
    ),
  );

  $query = array();
  if (isset($context['token'])) {
    $query['quant_token'] = $context['token'];
  }
  elseif (isset($context['id'])) {
    // Create a short-lived token to grant node access.
    $query['quant_token'] = quant_token_create($context['id']);
  }

  if (isset($context['vid']) && $context['type'] == 'node') {
    $query['quant_revision'] = $context['vid'];
  }

  if (strpos($url, '?') === false) {
    $response = drupal_http_request("$url?" . drupal_http_build_query($query), $options);
  }
  else {
    $response = drupal_http_request("$url&" . drupal_http_build_query($query), $options);
  }

  // Add a redirect if 301|302.
  if (isset($response->redirect_code) && ($response->redirect_code == 301 || $response->redirect_code == 302)) {
    // Strip quant params from destination.
    $dest = _remove_quant_params($response->redirect_url);

    // Ensure relative for internal redirect.
    $dest = _rewrite_relative($dest);

    if (module_exists('quant_redirect')) {
      quant_redirect_request($path, $dest, (int)$response->redirect_code);
    }

    // Ensure internal redirects have their destination seeded.
    if (_is_url_internal($dest)) {
      $dest_path = parse_url($dest, PHP_URL_PATH);
      $base = variable_get('quant_base_url', $base_url);
      quant_seed("{$base}{$dest_path}", array());
    }
    else {
      return;
    }
  }

  if ($response->code == 404) {
    // Ensure that the route is not accessible in Quant.
    quant_api_unpublish_route($url);
    return FALSE;
  }

  if (!property_exists($response, 'data') || $response->code >= 400) {
    quant_log('Unable to seed %url %error %request', array(
      '%url' => $url,
      '%error' => $response->error,
      '%request' => json_encode($response),
    ), WATCHDOG_ERROR);
    return FALSE;
  }

  $markup = $response->data;

  // Parse pages from Views and Taxonomy entities
  if (isset($context['find_pager']) && $context['find_pager']) {

    $document = new \DOMDocument();
    @$document->loadHTML($markup);
    $xpath = new \DOMXPath($document);

    /** @var \DOMElement $node */
    $pager_operations = [];
    $page_urls = isset($context['page_urls']) ? $context['page_urls'] : [];
    foreach ($xpath->query('//a[contains(@href,"page=") and contains(text(), "next")]') as $node) {

      $original_href = $node->getAttribute('href');
      if ($original_href[0] === '?') {
        $new_href = strtok($path, '?') . $original_href;
      }
      else {
        $new_href = $original_href;
      }

      global $base_url;
      $base = variable_get('quant_base_url', $base_url);
      $pager_url = _remove_quant_params($base.$new_href);

      if (in_array($pager_url, $page_urls)) {
        continue;
      }

      $page_urls[] = $pager_url;
      $pager_operations[] = array(
       'quant_seed',
        array($pager_url, [
          'find_pager' => TRUE,
          'type' => 'view',
          'page_urls' => $page_urls,
        ]),
      );

    }

    $b = array(
      'title' => t('Seeding views (Pages)'),
      'operations' => $pager_operations,
      'finished' => '_quant_batch_complete',
      'init_message' => t('Initialising...'),
      'progress_message' => t('Exporting views page @current out of @total'),
      'error_message' => t('Unable to export'),
      'file' => drupal_get_path('module', 'quant') . 'quant.module',
    );
    batch_set($b);
  }


  // Rewrite absolute URLs if relevant.
  if (variable_get('quant_rewrite_relative', FALSE)) {
    $markup = _rewrite_relative($markup);
  }

  // Ensure quant query parameters are removed.
  $markup = _remove_quant_params($markup);

  $alias = parse_url($url, PHP_URL_PATH);
  $alias = empty($alias) ? '/' : $alias;

  // Support query parameters (pagination).
  $query = parse_url($url, PHP_URL_QUERY);
  $alias = !empty($query) ? $alias . "?{$query}" : $alias;

  $meta = [
    'published' => TRUE,
    'transitions' => [],
    'info' => [],
  ];

  if (!empty($response->headers['content-type'])) {
    $meta['content_type'] = $response->headers['content-type'];
  }

  if (isset($context['type'])) {
    drupal_alter("quant_meta_{$context['type']}", $meta, $context);
  }
  drupal_alter('quant_meta', $meta, $context);
  module_invoke_all('quant_seed', $alias, $markup, $meta, $context);
}

/**
 * Prepare a file export.
 */
function quant_seed_file($url, $context = array()) {
  // @TODO: Files need different meta?
  $meta = array();
  drupal_alter('quant_file_meta', $meta, $context);
  module_invoke_all('quant_seed_file', $url, $context);
}

/**
 * Drush or watchdog logging.
 */
function quant_log($message, $replacements = array(), $level = WATCHDOG_INFO) {
  $vvv = variable_get('quant_verbose_logging', FALSE);

  if ($level == QUANT_VERBOSE && !$vvv) {
    return;
  }

  if ($level == QUANT_VERBOSE) {
    $level = WATCHDOG_INFO;
  }

  if (drupal_is_cli()) {
    drush_log(t($message, $replacements), 'ok');
    return;
  }

  watchdog('quant', $message, $replacements, $level);
}

/**
 * Implements hook_quant_meta_TYPE_alter().
 */
function quant_quant_meta_node_alter(&$meta, $context) {
  $meta['published'] = boolval($context['entity']->status);
  $meta['content_timestamp'] = $context['entity']->changed;
  $meta['info'] = [
    'author' => empty($context['entity']->revision_uid) ? $context['entity']->uid : $context['entity']->revision_uid,
  ];
}

/**
 * Implements hook_quant_meta_TYPE_alter().
 */
function quant_quant_meta_taxonomy_term(&$meta, $context) {
  global $user;
  $meta['info'] = [
    'author' => $user->uid,
  ];
  $meta['content_timestamp'] = time();
}

/**
 * Implements hook_quant_meta_alter().
 */
function quant_quant_meta_alter(&$meta, $context) {
  $meta['proxy_override'] = boolval(variable_get('quant_proxy_override', FALSE));
  if (!isset($meta['published'])) {
    // Assume the asset is to be published if not set.
    $meta['published'] = TRUE;
  }
}

/**
 * Prepare an arbitrary route for exporting.
 *
 * @return array
 *   The path with context for seeding.
 */
function _quant_prepare_route($url) {

}

/**
 * Prepare an entity for exporting.
 *
 * @return array
 *   The path with context for seeding.
 */
function _quant_prepare_entity($type, $entity_id) {
  global $base_url;
  $base = variable_get('quant_base_url', $base_url);
  $entity = entity_load($type, [$entity_id]);

  if (empty($entity)) {
    return FALSE;
  }

  $entity = reset($entity);
  $uri = entity_uri($type, $entity);
  $path = $uri['path'];
  $alias = drupal_get_path_alias($path);

  list($id, $vid) = entity_extract_ids($type, $entity);

  return [
    "$base/$alias",
    [
      'entity' => $entity,
      'vid' => $vid,
      'id' => $id,
      'type' => $type,
    ],
  ];
}

/**
 * Prepare a batch process for the node entity type.
 *
 * @param array $batch
 *   The batch array.
 */
function _quant_batch_nodes(&$batch, $bundles = array()) {
  global $base_url;
  $base = variable_get('quant_base_url', $base_url);

  $query = db_select('node', 'n')
    ->fields('n', array('nid'))
    ->condition('status', 1);

  if (!empty($bundles)) {
    $query->condition('n.type', array_keys($bundles), 'IN');
  }

  $nids = $query
    ->execute()
    ->fetchCol();

  // Add the homepage to the operations.
  $batch['operations'][] = array('quant_seed', array("$base/", array()));

  foreach ($nids as $nid) {
    quant_log('Adding [!nid] to the list.', array('!nid' => $nid));
    $batch['operations'][] = array(
      'quant_seed_node_batch',
      array($nid),
    );
  }

  return $batch;
}

/**
 * Prepare a batch process for taxonomy entities.
 *
 * @param array $batch
 *   The batch array.
 */
function _quant_batch_taxonomy(&$batch) {
  global $base_url;
  $base = variable_get('quant_base_url', $base_url);

  // @todo: Support select vocabs.
  $tids = db_select('taxonomy_term_data', 't')
    ->fields('t', array('tid'))
    ->execute()
    ->fetchCol();

  foreach ($tids as $tid) {
    quant_log('Adding [!tid] to the list.', array('!tid' => $tid));
    $batch['operations'][] = array(
      'quant_seed_taxonomy_batch',
      array($tid),
    );
  }

  return $batch;

}


/**
 * Prepare the images to seed via batch.
 *
 * @param array $batch
 *   The batch array.
 */
function _quant_batch_images(&$batch) {
  $theme_dir = drupal_get_path('theme', variable_get('theme_default', NULL));

  $files = file_scan_directory(DRUPAL_ROOT . "/$theme_dir", QUANT_THEME_FILE_MASK);

  // Allow modules to provide some files if they need to.
  drupal_alter('quant_seed_files', $file);

  foreach ($files as $file) {
    $path = urldecode($file->uri);

    $context = array(
      'location' => $file->uri,
      'request' => str_replace(DRUPAL_ROOT, '', $file->uri),
    );

    quant_log('Preparing !path', array('!path' => $path));

    $batch['operations'][] = array(
      'quant_seed_file',
      array($path, $context),
    );
  }
}

/**
 * Get a list of views paths.
 *
 * @param array $batch
 *   The batch array.
 */
function _quant_batch_views(&$batch) {
  global $base_url;
  $base = variable_get('quant_base_url', $base_url);

  $menus = array();

  if (module_exists('views')) {
    views_menu_alter($menus);
  }

  foreach ($menus as $path => $config) {
    $url = "$base/$path";

    $config['find_pager'] = TRUE;
    $config['type'] = 'view';

    // @TODO: We have menu access callbacks so we should
    // validate anonymous has access before we add the operation.
    // Pages will be exported to quant with 401.
    $batch['operations'][] = array(
      'quant_seed',
      array($url, $config),
    );
  }
}

/**
 * Generate a batch of arbitrary routes.
 *
 * @param array $batch
 *   The batch array.
 * @param string $routes
 *   Textarea entered routes.
 */
function _quant_batch_routes(&$batch, $routes) {
  global $base_url;
  $base = variable_get('quant_base_url', $base_url);

  $routes = is_array($routes) ? $routes : explode(PHP_EOL, $routes);

  foreach ($routes as $route) {
    if (strpos((trim($route)), '/') !== 0) {
      continue;
    }

    $url = $base . $route;

    $batch['operations'][] = array(
      'quant_seed',
      array(trim($url)),
    );
  }
}

/**
 * Batch processor for exporting nodes.
 */
function quant_seed_node_batch($nid) {
  list($url, $context) = _quant_prepare_entity('node', $nid);
  quant_seed($url, $context);
}

/**
 * Batch processor for exporting taxonomy terms.
 */
function quant_seed_taxonomy_batch($tid) {
  list($url, $context) = _quant_prepare_entity('taxonomy_term', $tid);

  // Find pagination within taxonomy term pages.
  $context['find_pager'] = TRUE;
  $context['type'] = 'taxonomy_term';

  quant_seed($url, $context);
}

/**
 * Create the batch process to export the form.
 *
 * @param array $form
 *   The form render array.
 * @param array $form_state
 *   The submitted form values.
 */
function _quant_seed_prepare($form = array(), $form_state = array()) {
  if (!empty($form_state['values']) && $form_state['values']['quant_seed'] == 0) {
    drupal_set_message('Quant: Skipping the batch process.', 'warning');
    return [];
  }

  $batch = array(
    'title' => t('Quant seeding'),
    'operations' => array(),
    'finished' => '_quant_batch_complete',
    'init_message' => t('Initialising...'),
    'progress_message' => t('Operation @current out of @total'),
    'error_message' => t('Unable to export'),
    'file' => drupal_get_path('module', 'quant') . 'quant.module',
  );

  $node_bundles = array_filter(variable_get('quant_seed_entity_node_bundles'));
  if (variable_get('quant_seed_entity_node')) {
    _quant_batch_nodes($batch, $node_bundles);
  }

  if (variable_get('quant_seed_entity_taxonomy')) {
    _quant_batch_taxonomy($batch);
  }

  if (variable_get('quant_seed_theme_assets')) {
    _quant_batch_images($batch);
  }

  if (variable_get('quant_seed_views')) {
    _quant_batch_views($batch);
  }

  if (variable_get('quant_custom_routes')) {
    _quant_batch_routes($batch, variable_get('quant_custom_routes'));
  }

  if (variable_get('quant_robots')) {
    _quant_batch_routes($batch, array('/robots.txt'));
  }

  // Allow module to alter the operation.
  drupal_alter('quant_seed', $batch);

  quant_log('Total operations [!total]', array(
    '!total' => count($batch['operations']),
  ));

  batch_set($batch);
}

/**
 * Generate warning messsages for the seed form.
 *
 * @param array &$form
 *   The form render array.
 */
function _quant_get_seed_warnings(&$form) {
  $cssagg = variable_get('preprocess_css');
  $jsagg = variable_get('preprocess_js');

  if ($cssagg == 1 && $jsagg == 1) {
    // Good things get no warnings.
    return;
  }

  if ($cssagg == 0) {
    drupal_set_message(t('CSS aggregation is disabled'), 'warning');
  }

  if ($jsagg == 0) {
    drupal_set_message(t('JS aggregation is disabled'), 'warning');
  }

  drupal_set_message(t('This could lead to performance issues. To resolve, visit /admin/config/development/performance'), 'warning');
}

/**
 * Export static pages.
 *
 * This gathers front and error pages and prepares them to be
 * exported.
 */
function quant_export_drupal_pages() {
  global $base_url;
  $base = variable_get('quant_base_url', $base_url);

  $special_pages = array(
    '/' => variable_get('site_frontpage', 'node'),
    '/_quant404' => variable_get('site_404'),
    '/_quant403' => variable_get('site_403'),
  );

  foreach ($special_pages as $path => $route) {
    if (empty($route)) {
      continue;
    }
    quant_seed("{$base}{$path}", array());
  }
}

/**
 * Add a short-lived token to the table.
 *
 * @return string
 *   The generated token.
 */
function quant_token_create($nid) {
  // This is slightly different to the D8 implementation
  // openssl produces different characters that get_query_parameters
  // cannot handle correctly so we just use random bytes.
  if (function_exists('random_bytes')) {
    $bytes = random_bytes(ceil(16 / 2));
    $token = substr(bin2hex($bytes), 0, 16);
  } else {
    $token = bin2hex(random_bytes(16));
  }

  $token = base64_encode($token);

  try {
    db_insert('quant_token')
      ->fields(array(
        'token' => $token,
        'nid' => $nid,
        'created' => REQUEST_TIME,
      ))
      ->execute();
  }
  catch (\Exception $error) {
    var_dump($error->getMessage());
  }

  return $token;
}

/**
 * Load and validate a token.
 *
 * @return bool
 *   If the token is valid.
 */
function quant_token_validate($nid, $strict = TRUE) {
  $params = drupal_get_query_parameters();

  if (empty($params['quant_token'])) {
    return FALSE;
  }

  $record = db_select('quant_token', 'qt')
    ->fields('qt', ['nid', 'created'])
    ->condition('token', $params['quant_token'])
    ->execute()
    ->fetchAssoc();

  if (empty($record) || empty($record['created']) || empty($record['nid'])) {
    // Something went wrong, we don't have the fields we need.
    return FALSE;
  }

  // Self-destruct for the token.
  // db_delete('quant_token')->condition('token', $params['quant_token'])->execute();

  if (!$strict) {
    return TRUE;
  }

  $valid_until = strtotime(QUANT_ELAPSED_TIME, $record['created']);
  return REQUEST_TIME < $valid_until && $nid == $record['nid'];
}

/**
 * Replaces absolute URLs with relative in markup.
 */
function _rewrite_relative($markup) {
  global $base_url;
  $base = variable_get('quant_hostname', $base_url);
  return preg_replace("/(https?:\/\/)?{$base}/i", '', $markup);
}

/**
 * Determines whether a URL is internal or external.
 */
function _is_url_internal($url) {
  global $base_url;
  $base = variable_get('quant_hostname', $base_url);
  if (preg_match("/(https?:\/\/)?{$base}/i", $url)) {
    return TRUE;
  }

  if (strpos($url, '/') === 0) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Removes quant params from markup.
 */
function _remove_quant_params($markup) {

  // Ensure &amp; is replaced with &
  $markup = preg_replace('/&amp;/i', '&', $markup);

  // Replace ?quant_revision=XX&quant_token=XX&additional_params with ?
  $markup = preg_replace('/\?quant_revision=(.*&)quant_token=(.*&)/i', '?', $markup);
  // Remove ?quant_revision=XX&quant_token=XX
  $markup = preg_replace("/\?quant_revision=(.*&)quant_token=[^\"']*/i", '', $markup);
  // Remove &quant_revision=XX&quant_token=XX with optional params
  $markup = preg_replace("/\&quant_revision=(.*&)quant_token=[^\"'&]*/i", '', $markup);

  // Replace ?quant_revision=XX&additional_params with ?
  $markup = preg_replace('/\?quant_revision=(.*&)/i', '?', $markup);
  // Remove ?quant_revision=XX
  $markup = preg_replace("/\?quant_revision=[^\"']*/i", '', $markup);
  // Remove &quant_revision=XX with optional params
  $markup = preg_replace("/\&quant_revision=[^\"'&]*/i", '', $markup);

  // Replace ?quant_token=XX&additional_params with ?
  $markup = preg_replace('/\?quant_token=(.*&)/i', '?', $markup);
  // Remove ?quant_token=XX
  $markup = preg_replace("/\?quant_token=[^\"']*/i", '', $markup);
  // Remove &quant_token=XX with optional params
  $markup = preg_replace("/\&quant_token=[^\"'&]*/i", '', $markup);

  return $markup;
}

/**
 * Implements hook_form_FORM_ID_alert().
 */
function quant_form_workbench_moderation_moderate_form_alter(&$form, $form_state, $id) {
  $form['#submit'][] = 'quant_workbench_moderation_submit';
}

/**
 * Form submission handler.
 *
 * @see workbench_moderation_moderate_form_submit
 */
function quant_workbench_moderation_submit($form, $form_state) {
  $node = $form['node']['#value'];

  $entity_info = array(
    'entity' => $node,
    'type' => 'node',
    'op' => 'update',
    'original' => $node->original,
  );

  if ($form_state['values']['state'] == workbench_moderation_state_published()) {
    drupal_register_shutdown_function('_quant_shutdown', $entity_info);
  }
  else {
    list($url) = _quant_prepare_entity('node', $form['node']['#value']->nid);
    quant_api_unpublish_route($form_state['values']['alias']);
  }
}
